import {serveDir, serveFile, type ServeDirOptions} from '@std/http/file-server';
import * as path from '@std/path'
import {Forager} from '@forager/core'
import {Logger, type LogLevel} from '@forager/core/logger'
import { trace } from "@opentelemetry/api"

// these relative imports are generated by the adapter in the build step
import * as forager_config from './build/config.ts'
import build_manifest from './build/build.json' with { type: 'json' }

import {Server as KitServer} from './build/server/index.js';
import {manifest} from './build/server/manifest.js';
import * as static_asset_bytes from './build/bytes_imports.ts'
export const kitServer = new KitServer(manifest as any);

interface ServerOptions {
  // log level for server messages
  logger?: {
    level: LogLevel
  }

  // the port the server is hosted on
  port?: number

  // the folder the static browser assets are downloaded into and served from
  asset_folder: string

  // special flag used for development. Disables fetching of assets from jsr.io
  preview?: boolean

  kit?: {
    // the key/value pair of environment variables handed to svelte kit server
    env?: Record<string, string>
  }
}

class Server {
  #options: ServerOptions
  #server?: Deno.HttpServer
  #prerendered: Set<string>
  #appDir: string
  #baseDir: string
  #rootDir: string
  #kitServerInitialized!: Promise<void>
  #logger: Logger
  #routes: {
    favicon: URLPattern
    immutable_asset: URLPattern
    static_asset: URLPattern
  }
  #serve_dir_options: ServeDirOptions

  constructor(options: ServerOptions) {
    this.#logger = new Logger('forager.web', options?.logger?.level)
    this.#options = options ?? {}
    this.#prerendered = new Set(build_manifest.PRERENDERED);
    this.#appDir = build_manifest.APP_DIR;
    this.#baseDir = path.dirname(new URL(import.meta.url).pathname);
    if (options.preview) {
      this.#rootDir = path.join(this.#baseDir, 'build', 'static');
    } else {
      this.#rootDir = path.join(this.#options.asset_folder, build_manifest.package_version)
    }
    this.#routes = {
      favicon: new URLPattern({
        pathname: '/favicon.png',
      }),
      immutable_asset: new URLPattern({
        pathname: `/${this.#appDir}/immutable/*`,
      }),
      static_asset: new URLPattern({
        pathname: `/${this.#appDir}/*`,
      })
    }
    this.#serve_dir_options = {
      fsRoot: this.#rootDir,
      quiet: this.#options.logger?.level !== 'DEBUG',
    }
  }

  async init() {
    await this.#ensure_static_assets_exist()

    this.#logger.debug('Initializing sveltekit server instance')
    const env = this.#options?.kit?.env ?? Deno.env.toObject()
    this.#kitServerInitialized = kitServer.init({ env })
    await this.#kitServerInitialized
  }

  async start(): Promise<void> {
    this.#logger.debug('Starting deno http server')
    this.#server = Deno.serve({
      hostname: '127.0.0.1', // Only bind to localhost'
      port: this.#options.port ?? 8000,
      onError: (error) => {
        this.#logger.error(`An error occured on the server: ${error}`)
        return new Response('Internal Error', {status: 500})
      },
      onListen: (addr) => {
        this.#logger.info(`Listening on ${addr.hostname}:${addr.port}`)
        this.#logger.debug(`@forager/web version ${build_manifest.package_version}`)
        this.#logger.debug(`static assets served from ${this.#rootDir}`)
      },
    }, this.#handle_request)

    await this.#server.finished
  }

  get status(): Promise<void> | undefined {
    return this.#server?.finished
  }

  async shutdown() {
    if (this.#server === undefined) {
      throw new Error("Server has not been started yet")
    }
    await this.#server.shutdown()
  }

  async #ensure_static_assets_exist() {
    // in preview mode, we will just use the locally generated built files
    if (this.#options.preview) {
      return
    }

    const static_assets_folder = path.join(this.#options.asset_folder, build_manifest.package_version)

    // check if the version assets are already downloaded in the asset folder
    try {
      const dir_stats = await Deno.stat(static_assets_folder)
      if (!dir_stats.isDirectory) {
        throw new Error(`Unexpected code path. Static asset dir ${static_assets_folder} is a file, not a directory`)
      }
      await this.#check_asset_dir_contents(static_assets_folder)
      return
    } catch (e) {
      if (e instanceof Deno.errors.NotFound) {
        /* this is handled below */
      } else {
          throw e
        }
    }

    this.#logger.debug(`Clearing away any old files in ${this.#options.asset_folder}.`)
    // if it doesnt exist, just clear the whole dir away and start over
    await Deno.remove(this.#options.asset_folder, {recursive: true}).catch(e => {
      if (e instanceof Deno.errors.NotFound) { /* we can safely ignore this, since we're trying to remove the dir */ }
      else { throw e }
    })

    this.#logger.debug(`Writing static assets from raw imports into folder ${static_assets_folder}`)

    for (const [file_id, file_bytes] of Object.entries(static_asset_bytes) as [string, Uint8Array][]) {
      const relative_path = build_manifest.generated_files[file_id as keyof typeof build_manifest.generated_files]
      const asset_output_path = path.join(static_assets_folder, relative_path)
      await Deno.mkdir(path.dirname(asset_output_path), { recursive: true })
      await Deno.writeFile(asset_output_path, file_bytes)
      this.#logger.debug(`Wrote ${asset_output_path}`)
    }

    await this.#check_asset_dir_contents(static_assets_folder)
    this.#logger.debug(`Completed writing asset files to ${static_assets_folder}`)
  }

  async #check_asset_dir_contents(folder: string) {
    const dir_entries = await Array.fromAsync(Deno.readDir(folder))
    const dir_filenames = dir_entries.map(entry => entry.name)
    if (dir_filenames.length !== 2 || !dir_filenames.includes('favicon.png') || !dir_filenames.includes('_app')) {
      throw new Error(`Root dir ${this.#rootDir} does not contain expected asset files`)
    }
  }

  #handle_request = async (request: Request, info: Deno.ServeHandlerInfo<Deno.NetAddr>): Promise<Response> => {
    const span = trace.getActiveSpan()
    if (span) {
      const url_pathname = new URL(request.url).pathname
      span.updateName(`${request.method} ${url_pathname}`)
    }
    this.#logger.debug(() => {
      const endpoint = `${request.method} ${request.url}`
      return endpoint
      /*
      const headers = `${[...request.headers.entries()].map(entry => `  ${entry[0]}: ${entry[1]}`).join('\n')}`
      return `${endpoint}\n${headers}`
      */
    })

    const url = new URL(request.url)

    /*
    // Path has trailing slash
    const {pathname} = url
    const slashed = pathname.at(-1) === '/';

    // Handle trailing slash redirects for prerendered routes
    const location = slashed ? pathname.slice(0, -1) : `${pathname}/`;
    if (this.#prerendered.has(location)) {
      return new Response(null, {
        status: 308,
        statusText: 'Permanent Redirect',
        headers: {
          location
        }
      });
    }

    // Try prerendered route with html extension
    if (!slashed && !path.extname(pathname) && this.#prerendered.has(pathname)) {
      this.#logger.debug(`try respond with prerendered ${pathname}.html`)
      const response = await serveFile(
        request,
        path.join(this.#rootDir, `${pathname}.html`)
      );
      if (response.ok || response.status === 304) {
        return response;
      }
    }
    */

    // Try static files (ignore redirects and errors)
    if (this.#routes.static_asset.test(url) || this.#routes.favicon.test(url)) {
      this.#logger.debug(`respond with @std/http/file-server::serveDir`)
      const response = await serveDir(request, this.#serve_dir_options)
      if (response.ok || response.status === 304) {
        if (this.#routes.immutable_asset.test(url)) {
          response.headers.set('cache-control', 'public, max-age=31536000, immutable')
        }
        return response
      }
    }

    this.#logger.debug(`respond with @sveltekit server`)
    // Pass to the SvelteKit server
    await this.#kitServerInitialized
    return kitServer.respond(request, {
      getClientAddress() {
        // Get client IP address
        return request.headers.get('x-forwarded-for') ?? info.remoteAddr.hostname;
      }
    });
  }
}


if (import.meta.main) {
  const env: Record<string, any> = {}
  const FORAGER_CONFIG = Deno.env.get('FORAGER_CONFIG')
  if (FORAGER_CONFIG === undefined) {
    throw new Error(`FORAGER_CONFIG environment variable must be set to run @forager/web module directly`)
  }
  const config = await forager_config.load_config(FORAGER_CONFIG)
  if (config.web.editing) {
    config.core.editing = config.web.editing
  }
  env.FORAGER_CONFIG = config
  const forager = new Forager(config.core)
  forager.init()
  env.FORAGER_INSTANCE = forager
  const server = new Server({
    logger: config.web.logger,
    asset_folder: path.join(Deno.cwd(), 'static_assets'),
    preview: true,
    kit: {
      env,
    }
  })
  await server.init()
  await server.start()
}


export { Server }
export { PackagesConfig } from './build/config.ts'
