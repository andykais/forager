import {serveDir, serveFile, type ServeDirOptions} from '@std/http/file-server';
import * as path from '@std/path'
import {Forager} from '@forager/core'
import {Logger, type LogLevel} from '@forager/core/logger'
import { trace } from "@opentelemetry/api"

// these relative imports are generated by the adapter in the build step
import {kitServer} from './server.js';
import {load_config} from './config.ts'

import deno_json from './deno.json' with { type: 'json' }

interface ServerOptions {
  // log level for server messages
  logger?: {
    level: LogLevel
  }

  // the port the server is hosted on
  port?: number

  // the folder the static browser assets are downloaded into and served from
  asset_folder: string

  // special flag used for development. Disables fetching of assets from jsr.io
  preview?: boolean

  kit?: {
    // the key/value pair of environment variables handed to svelte kit server
    env?: Record<string, string>
  }
}

interface JsrManifest {
  manifest: Record<string, {size: number, checksum: string}>
}

interface LocalManifest {
  version: string
  files: string[]
}

class Server {
  #options: ServerOptions
  #server?: Deno.HttpServer
  #prerendered: Set<string>
  #appDir: string
  #baseDir: string
  #rootDir: string
  #kitServerInitialized!: Promise<void>
  #logger: Logger
  #routes: {
    favicon: URLPattern
    immutable_asset: URLPattern
    static_asset: URLPattern
  }
  #serve_dir_options: ServeDirOptions

  constructor(options: ServerOptions) {
    this.#logger = new Logger('forager.web', options?.logger?.level)
    this.#options = options ?? {}
    this.#prerendered = new Set(PRERENDERED);
    this.#appDir = 'APP_DIR';
    this.#baseDir = path.dirname(new URL(import.meta.url).pathname);
    if (options.preview) {
      this.#rootDir = path.join(this.#baseDir, 'static');
    } else {
      this.#rootDir = path.join(this.#options.asset_folder, deno_json.version, 'static')
    }
    this.#routes = {
      favicon: new URLPattern({
        pathname: '/favicon.png',
      }),
      immutable_asset: new URLPattern({
        pathname: `/${this.#appDir}/immutable/*`,
      }),
      static_asset: new URLPattern({
        pathname: `/${this.#appDir}/*`,
      })
    }
    this.#serve_dir_options = {
      fsRoot: this.#rootDir,
      quiet: this.#options.logger?.level !== 'DEBUG',
    }
  }

  async init() {
    if (!this.#options.preview) {
      await this.#fetch_static_assets()
    }
    const dirEntries = await Array.fromAsync(Deno.readDir(this.#rootDir))
    const dirFilenames = dirEntries.map(entry => entry.name)
    if (dirFilenames.length !== 2 || !dirFilenames.includes('favicon.png') || !dirFilenames.includes('_app')) {
      throw new Error(`Root dir ${this.#rootDir} does not contain expected asset files`)
    }

    this.#logger.debug('Initializing sveltekit server instance')
    const env = this.#options?.kit?.env ?? Deno.env.toObject()
    this.#kitServerInitialized = kitServer.init({ env })
    await this.#kitServerInitialized
  }

  async start(): Promise<void> {
    this.#logger.debug('Starting deno http server')
    this.#server = Deno.serve({
      hostname: '127.0.0.1', // Only bind to localhost'
      port: this.#options.port ?? 8000,
      onError: (error) => {
        this.#logger.error(`An error occured on the server: ${error}`)
        return new Response('Internal Error', {status: 500})
      },
      onListen: (addr) => {
        this.#logger.info(`Listening on ${addr.hostname}:${addr.port}`)
        this.#logger.debug(`@forager/web version ${deno_json.version}`)
        this.#logger.debug(`static assets served from ${this.#rootDir}`)
      },
    }, this.#handle_request)

    await this.#server.finished
  }

  get status(): Promise<void> | undefined {
    return this.#server?.finished
  }

  async shutdown() {
    if (this.#server === undefined) {
      throw new Error("Server has not been started yet")
    }
    await this.#server.shutdown()
  }

  async #fetch_static_assets() {
    const local_manifest_path = path.join(this.#options.asset_folder, 'manifest.json')
    const static_assets_folder = path.join(this.#options.asset_folder, deno_json.version)

    try {
      const file_contents = await Deno.readTextFile(local_manifest_path)
      const local_manifest: LocalManifest = JSON.parse(file_contents)
      if (local_manifest.version !== deno_json.version) {
        this.#logger.debug(`Local manifest version ${local_manifest.version} does not match target version. Clearing asset folder ${this.#options.asset_folder}.`)
        await Deno.remove(this.#options.asset_folder, {recursive: true})
      } else {
        // everything up to date, nothing else to do
        return
      }
    } catch (e) {
      if (e instanceof Deno.errors.NotFound) {
        this.#logger.debug(`No local manifest found`)
      } else {
        await Deno.remove(this.#options.asset_folder, {recursive: true})
      }
    }

    this.#logger.debug(`Fetching static assets from jsr package ${deno_json.version} into folder ${static_assets_folder}`)
    const jsr_manifest_res = await fetch(`https://jsr.io/@forager/web/${deno_json.version}_meta.json`)
    const jsr_manifest = await jsr_manifest_res.json()
    const static_assets = Object.keys(jsr_manifest.manifest)

    for (const remote_asset_path of static_assets) {
      // chop off the leading "/" on assets
      const asset_path = remote_asset_path.substring(1)

      const url = `https://jsr.io/@forager/web/${deno_json.version}/${asset_path}`
      this.#logger.debug(`Fetching ${url}`)
      const response = await fetch(url)
      const asset_output_path = path.join(static_assets_folder, asset_path)
      await Deno.mkdir(path.dirname(asset_output_path), { recursive: true })
      const asset_file = await Deno.open(asset_output_path, { createNew: true, write: true })
      await response.body?.pipeTo(asset_file.writable)
      this.#logger.debug(`Saved ${asset_output_path}`)

      const static_assets_manifest: LocalManifest = {
        version: deno_json.version,
        files: static_assets,
      }
      await Deno.writeTextFile(
        local_manifest_path,
        JSON.stringify(static_assets_manifest)
      )
    }
  }

  #handle_request = async (request: Request, info: Deno.ServeHandlerInfo): Promise<Response> => {
    const span = trace.getActiveSpan()
    if (span) {
      const url_pathname = new URL(request.url).pathname
      span.updateName(`${request.method} ${url_pathname}`)
    }
    this.#logger.debug(() => {
      const endpoint = `${request.method} ${request.url}`
      return endpoint
      /*
      const headers = `${[...request.headers.entries()].map(entry => `  ${entry[0]}: ${entry[1]}`).join('\n')}`
      return `${endpoint}\n${headers}`
      */
    })

    const url = new URL(request.url)

    /*
    // Path has trailing slash
    const {pathname} = url
    const slashed = pathname.at(-1) === '/';

    // Handle trailing slash redirects for prerendered routes
    const location = slashed ? pathname.slice(0, -1) : `${pathname}/`;
    if (this.#prerendered.has(location)) {
      return new Response(null, {
        status: 308,
        statusText: 'Permanent Redirect',
        headers: {
          location
        }
      });
    }

    // Try prerendered route with html extension
    if (!slashed && !path.extname(pathname) && this.#prerendered.has(pathname)) {
      this.#logger.debug(`try respond with prerendered ${pathname}.html`)
      const response = await serveFile(
        request,
        path.join(this.#rootDir, `${pathname}.html`)
      );
      if (response.ok || response.status === 304) {
        return response;
      }
    }
    */

    // Try static files (ignore redirects and errors)
    if (this.#routes.static_asset.test(url) || this.#routes.favicon.test(url)) {
      this.#logger.debug(`respond with @std/http/file-server::serveDir`)
      const response = await serveDir(request, this.#serve_dir_options)
      if (response.ok || response.status === 304) {
        if (this.#routes.immutable_asset.test(url)) {
          response.headers.set('cache-control', 'public, max-age=31536000, immutable')
        }
        return response
      }
    }

    this.#logger.debug(`respond with @sveltekit server`)
    // Pass to the SvelteKit server
    await this.#kitServerInitialized
    return kitServer.respond(request, {
      getClientAddress() {
        // Get client IP address
        return request.headers.get('x-forwarded-for') ?? info.remoteAddr.hostname;
      }
    });
  }
}


if (import.meta.main) {
  const env: Record<string, any> = {}
  const FORAGER_CONFIG = Deno.env.get('FORAGER_CONFIG')
  if (FORAGER_CONFIG === undefined) {
    throw new Error(`FORAGER_CONFIG environment variable must be set to run @forager/web module directly`)
  }
  const config = await load_config(FORAGER_CONFIG)
  if (config.web.editing) {
    config.core.editing = config.web.editing
  }
  env.FORAGER_CONFIG = config
  const forager = new Forager(config.core)
  env.FORAGER_INSTANCE = forager
  const server = new Server({
    logger: config.web.logger,
    asset_folder: path.join(Deno.cwd(), 'static_assets'),
    preview: true,
    kit: {
      env,
    }
  })
  await server.init()
  await server.start()
}


export { Server }
